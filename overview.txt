TICKETING APP

Resources
    User -   { email, password }
    Ticket - { title, price, userId, orderId }
    Order -  { userId, status, ticketId, expiresAt }
    Charge - { orderId, status, amount, stripeId, stripeRefundId }

Services
    auth - everything related to user signup/signin/signout
    tickets - ticket creation/editing
    orders - order creation/editing
    expiration - watches for orders to be created, cancels them after 15 min
    payments - handles payments, cancels order if payment fails, completes if succeeds

Design
    React Client App - Next JS
    Common - Library for common code/middlewares for services
    Services - Node servers with persistent database (MongoDb/Redis)
    NATS Streaming Server - Event bus

Kubernetes
    dir - infra/k8s
    use - the deployments: {service}-depl.yaml uses a image to create pods (containers) that run the service;
          also we create a corresponding ClusterIP service in {service}-depl.yaml;
          a ClusterIP service allows communication to the service from anything else running inside our cluster

Skaffold
    dir - ticketing/skaffold.yaml
    use - it is a config file, if a change is made to:
              - any .yaml file in infra/k8s dir, it will apply it to the cluster
              - any change in code in each service dir (auth/tickets/orders/expiration/payments),
                it will sync all the files in there with appropriate container in the cluster
    run - skaffold dev (in ticketing dir)

Ingress-Nginx
    To access a running server (any pod in our cluster), we can:
        1. set up NodePort service
        2. Ingress service - it has routing rules tied to Nginx
    dir - infra/k8s/ingress-srv.yaml
    use - anytime a request comes in to the cluster, it will be handled by the Ingress service and
          it will be routed off to the appropriate service within the cluster  

Host file edit and security warning
    dir - C:\Windows\System32\drivers\etc\hosts
    Edit the 'hosts' file by adding a line at the bottom:
        {IP} ticketing.dev
    [get the {IP} by running minikube ip command] 

    goto http://ticketing.dev
    when prompted with the 'Your connection is not private' error,
    click anywhere on the page and type 'thisisunsafe' 

User Authentication Strategy
    All the services know how to authenticate a user
    1. User sends a request along with its JWT that was assigned to it during signIn
           the cookie within the request contains JWT (cookie is a transportation mechanism)
           the JWT can be decrypted to get the payload (user info)
    2. The service checks if the JWT is valid to authenticate the user

Decrypting JWT and Secret key
    When we send a request, we get back JWT inside a cookie as a response from the app
    actually we get a base64 string that is generated by JSONify the req.session object that
    contains the actual JWT (see in auth/src/routes/signup.ts)
    go to http://base64decode.org to get the session object (containing JWT)
    go to http://jwt.io to get decrypt the JWT to get the payload (user info - id & email) providing the JWT and secret key
    
    Secret is a kind of object in Kubernetes, which can store {key, value} pairs
    we then assign the secret to environment variables of each services' pod, so all of them can use it
    >  kubectl create secret generic jwt-secret --from-literal=JWT_KEY=asdf (in ticketing)
    >  kubectl get secrets  (to get all secrets)
    also we will edit all the {srevice}-depl.yaml files to add the secret key

Database common response
    since we are using different databases (MongoDb, Redis), we want the response from each db to the app to be same
    i.e. we want a consistent response structure that look like:
        {   "id": "...",
            "email": "..."  }
    for ex. MongoDb returns a structure: { "_id": "...", "email": "...", "password": "...", "__v": "..."}


Auth Service
    Structure
            Route              Method           Body                   Purpose
        /api/users/signup         POST     { email, password }    Sign up for an account
        /api/users/signin         POST     { email, password }    Sign in to an existing account  
        /api/users/signout        POST             {}             Sign out
        /api/users/currentuser    GET             ----            Return info about user

    Initialization
        >  npm init -y
        >  npm install typescript ts-node-dev express @types/express
        >  tsc --init
        In 'package.json' file, edit "scripts" tag to look like:
            "scripts": {
                "start": "ts-node-dev --poll src/index.ts"
            }
        >  npm install express-validator
        >  npm install express-async-errors
        >  npm install mongoose
        >  npm install @types/mongoose
        >  npm install cookie-session @types/cookie-session
        >  npm install jsonwebtoken @types/jsonwebtoken
        >  npm install --save-dev @types/jest @types/supertest jest ts-jest supertest mongodb-memory-server
        Dockerfile edit - RUN npm install --only=prod
        package.json edit
            "scripts": {
                "start": "ts-node-dev --poll src/index.ts",
                "test": "jest --watchAll --no-cache"
            },
            "jest": {
                "preset": "ts-jest",
                "testEnvironment": "node",
                "setupFilesAfterEnv": [
                    "./src/test/setup.ts"
                ]
            }
        Run tests - npm run test (in auth dir)

        Goto ticketing.dev/api/users/currentuser
        To remove 'Your connection is not private' error,
        click anywhere on the page and type 'thisisunsafe'
        
        >  kubectl create secret generic jwt-secret --from-literal=JWT_KEY=asdf (in ticketing)
    
        >  npm install @pstickets/common

    Workflow
        src
            errors
            middlewares
            models - Mongoose User Model
            routes - a file for each 4 routes and it exports the corresponding routers to src/index.ts file
            services
            test

    Error Handling
        error should have a consistent structured response from all servers
        request -> Request Handler -> Error Handling Middleware -> structured error response
        error object structure
            { errors: { message: string, field?: string} [] }
        a CustomError abstract class is created which lays down the structure of every error:
            abstact statusCode: number;
            abstract serializeErrors(): { message: string; field?: string }[];
        every error class will extend the abstact CustomError class (to avoid implementation mistakes)

    Database (MongoDb)
        dir - infra/k8s/auth-mongo-depl.yaml    (deployment for MongoDb database for auth service)
              it creates a pod (a MongoDb instance); also a ClusterIP service to connect to the pod
              port: 27017 (default port for MongoDb)
              mongoose is used to connect to a MongoDb instance (mongoose.connect)

    SignUp
        1. ReactApp(client) makes a request with { email, password }
        2. Check if user with this email exists? if yes, respond with an error (ckeck User Collection in db)
           To access the User Collection, a mongoose User model needs to be created
        3. Hash the password
        4. Create a new User and save it to the db (again mongoose User model will be used)
        5. User is now logged in, send them a cookie that contains a JWT (JSON Web Token)

        User Collection will contain all the users: User#1, User#2, User#3, .... 
        Mongoose User Document - represents one single user
        Mongoose User Model - represents entire User Collection

    SignIn
        1. ReactApp(client) makes a request with { email, password }
        2. Check if user with this email exists? if yes, respond with an error
        3. Compare the password of stored user and the supplied password. if same good, else throw an error
        4. User is now logged in, send them a cookie that contains a JWT (JSON Web Token)
           
    CurrentUser
        1. ReactApp(client) makes a Current User request
        2. Check if the request has 'req.session.jwt' set
        3. If it is not set, or if JWT is invalid, return null
        4. If it is set, and the JWT is valid, send back the info stored in JWT (payload) as
           { currentUser: { id: '...', email: '...' } }  

    SignOut
        1. ReactApp(client) makes a SignOut request
        2. Destroy the session

    Testing
        We are running the tests directly from the terminal without using docker
        dir - test files of each dir will be in __test__ dir inside the dir
        Run command: >  npm run test         (in auth dir)
        It will start a test runner called Jest that will execute the tests
            1. Start in-memory copy of MongoDb
            2. Start up the express app
            3. Use supertest lib to make requests
            4. Run assertions to make sure the request did the right thing
        
        The index.js file is refractored to separate the app part in app.js
        app.js - express app that is not listening on any port
        index.js - import app.js, start app, and listen on port 3000
        test files - ipmort app.js, test app with supertest listening on some random port 
                     (so we can perform multiple services' test in parallel on different ports)
        
        The testing Initialization is done with the --save-dev so that we don't have to reinstall it (since it is large)
        The Dockerfile edit: [ RUN npm install--only=prod ] will ensure the command runs only in production mode


Server Side Redndering (NextJS)
    When user types 'ticketing.dev' in browser, the browser sends a 'GET ticketing.dev' request.
    NextJS inspects the URL and determines which component to show (in client/pages dir)
    Call those component's 'getInitialProps' static method (any data retured from it will be passed as props to the component)
    Render each component with data from getInitialProps one time 
    Finally NextJS sends a response back to the browser as a fully rendered HTML file with content

Fetching data during SSR
    Request by browser
        When browser makes a request, say [GET /api/users/currentuser],
        the browser adds a baseUrl: [https://ticketing.dev/api/users/currentuser],
        then network layer changes it to: [https://{minikube ip}/api/users/currentuser],
        and it is forwarded to Ingress-Nginx, and then to appropriate service

    Request by server (in Client pod)
        dir - client/api/build-client.js
        Problem
        When server (NextJS app) makes a request, say [GET /api/users/currentuser],
        the node's networking layer adds a default baseUrl: [GET localhost:80/api/users/currentuser],
        but since the NextJS app is inside a container, localhost:80 is inside the container, not the browser
        and since nothing is listening on localhost:80 inside the container, we get an error

        Solution
        The NextJS app should reach out to Ingress-Nginx, which is running inside the cluster
        then Ingress-Nginx will figure out the domain based on the request
            
            Cross Namespace Communication
            Within a namespace, pods can communicate using ClusterIP service
            here we have two namespaces (in minikube):
                default: pods running - client, auth, etc. (all microservices)
                kube-system: pods running - nginx-ingress-controller-{id}
            communication protocol: http://SERVICENAME.NAMESPACE.svc.cluster.local (general)
            it's a bit different in minikube:
            Get Ingress-Nginx namespace: (kube-system)
                >  kubectl get namespaces
            Get pod: (nginx-ingress-controller-{id}) 
                >  kubectl get pods -n kube-system
            Get IP_address:
                >  kubectl describe pod nginx-ingress-controller-{id} -n kube-system
            communication protocol: http://IP_address
        
    Hence we can use different baseUrl depending on which environment we're in (browser/server)
    To check whether in browser/server: window variable is only defined in browser

Calling getInitialProps
    getInitialProps is executed on server when:
        1. Hard refresh on page
        2. Clicking link from different domain
        3. Typing URL into address bar
    getInitialProps is executed on browser when:
        1. Navigating from one page to another while in the app

Handling multiple getInitialProps
    getInitialProps has different meaning of context in:
        page component - context === { req,res }
        app component  - context === { Component, ctx: { req, res } }
    so we will fetch the data in app component's getInitialProps and then pass
    down the necessary props to the getInitialProps of the page components that requires it


Client
    Initialization
        >  npm init -y
        >  npm install react react-dom next
        package.json edit
            "scripts": {
                "dev": "next"
            },
        >  docker build -t ps07/client .
        >  docker push ps07/client
        >  npm install bootstrap
        >  npm install axios
        >  npm install react-stripe-checkout

    Workflow
        pages - every file inside pages is a route 
                ex. abc.js points to the route https://ticketing.dev//abc
                except index.js points to the default route https://ticketing.dev
        hooks

    File change detection
        NextJS sometimes does not capture a file change when running inside a docker container
        To fix this issue, a 'next.config.js' file is created which polls all the files every 300ms
        rather than looking for any file changes.
        To apply this file, kill the client pod and it will automatically restart with this file applied

    Global CSS (Bootstrap)
        To import any Global CSS such as Bootstrap, it should be included only in 'pages/_app.js' file
        This will apply Bootstrap to every page inside the pages dir
    
    The useRequest hook
        dir - hooks/use-request.js
        use - a generalized hook for all kinds of requests such as get, post etc.
              input - { url, method, body, onSuccess }
              output - { doRequest, errors }

    BuildClient API
        dir - api/build-client.js
        use - takes an incoming request and returns a preconfigured version of axios
              server - sets baseUrl: http://IP_address (from Ingress-Nginx pod), sets header (cookie)
              browser - sets baseUrl: /

    AppComponent
        dir - pages/_app.js
        use - to show elements that would be visible on every single page such as Bootstrap and header

Code Sharing
    To share code between our microservices, create a NPM registry
    Login at http://npmjs.com and 'Add Organiztion' - pstickets (public)
    Login npm: >  npm login
    Publish package: >  npm run pub     (in common dir)
    Install package: >  npm install @pstickets/common       (in other dirs)
    Update package:  >  npm update @pstickets/common    (when an change is made in common dir code)


Common
    Initialization
        >  npm init -y
        >  npm install express express-validator cookie-session jsonwebtoken
        >  npm install @types/cookie-session @types/express @types/jsonwebtoken
        >  npm install node-nats-streaming
        package.json edit:
            "name": "@pstickets/common",
            "main": "./build/index.js",
            "types": "./build/index.d.ts",
            "files": [
                "./build/**/*"
            ],
            "scripts": {
                "clean": "del-cli ./build/*",
                "build": "npm run clean && tsc",
                "pub": "npm version patch && npm run build && npm publish --access public"
            }
        >  npm login
        >  tsc --init
        >  npm install typescript del-cli --save-dev
        tsconfig.json edit:
            "compilerOptions": {
                ---
                "declaration": true,
                "outDir": "./build",
                ---
            }
        >  tsc
        >  npm run pub

    Order status
        dir - common/src/events/types/order-status.ts
        use - All possible order status
              Created - When the order has been created, but the ticket it is 
                        trying to order has not been reserved
              Cancelled - The ticket the order is trying to reserve has already been reserved or
                          When the user has cancelled the order or
                          The order expires before the payment
              AwaitingPayment - The order has successfully reserved the ticket
              Complete - The order has reserved the ticket and the user has provided payment successfully



NATS Streaming Server (Event bus)
    Services publishes an event to a channel and other services 
    subscibes to that channel to listen the event
    ex. Tickets service publishes a TicketUpdatedEvent to ticket:updated channel
        and Orders service subscibes to ticket:updated channel to listen the event

    Subscription Options
        The service that subscibes to a channel has several options
        - setManualAckMode(true): manual acknowledgement of message
        - setAckWait(millis): number of milliseconds before a message is considered unacknowledged
        - setDeliverAllAvailable(): configures the subscription to replay from first available message
        - setDurableName(durableName): if service restart, it can acknowledge the leftver messages

    Queue Group
        NATS creates a group of subscrbers under the same Queue Group name
        a service can have multiple listeners and an event can go to either of them

    Solving Concurrency issues
        Network request to CRUD resource XYZ -> Serice that owns XYZ (-> db storing XYZ)
        -> Event describing change to XYZ -> NATS SS -> Event -> Service that needs to update its data

        In ticketing
            - browser sends a requests: { ticketId: 'CZQ', price: 50 } & { ticketId: 'CZQ', price: 100 }
            - goes to ticket service, that stores it in Tickets db as
              { ticketId: 'CZQ', price: 50, version: 1 } 
              { ticketId: 'CZQ', price: 50, version: 2 }    (version is incremented if ticket is updated)
            - ticket service emits events:
              ticket:created { id: 'CZQ', price: 50, version: 1 } - goes to ticket:created channel in NATS
              ticket:updated { id: 'CZQ', price: 100, version: 2 } - goes to ticket:updated channel in NATS
            - orders services has subscibed to both ticket:created and ticket:updated channels
              it has multiple listeners (say two, A and B)
            - order service receives the events and update info in Orders db iff db.id.version = event.version - 1
              so if ticket:created event fails for some reason, the Order db would not store ticket:updated data (sice version: 2)
              hence we store data in correct order and Concurrency issues are sorted


NATS-test
    Initialization
        >  npm init -y
        >  npm install node-nats-streaming ts-node-dev typescript @types/node
        >  tsc --init
        package.json edit:
            "scripts": {
                "publish": "ts-node-dev --notify false src/publisher.ts",
                "listen": "ts-node-dev --notify false src/listener.ts"
            },
        >  kubectl get pods     (get the nats pod: {pod})
        >  kubectl port-forward {pod} 4222:4222     (keep it running)
        >  npm run publish      (in new terminal)   can be restarted using 'rs'
        >  npm run listen       (in new terminal)   can be restarted using 'rs'
        >  kubectl port-forward {pod} 8222:8222     (Monitoring)
        goto - http://localhost:8222/streaming
        channel info - http://localhost:8222/streaming/channelsz?subs=1

    Connection
        To connect publisher to the NATS pod inside the cluster, port forwarding is used 
        on port 4222. monitoring is done done on port 8222. it is similar to NodePort service
        >  kubectl port-forward {pod} 4222:4222
        >  kubectl port-forward {pod} 8222:8222


Events
    Events published by each service
        tickets    - ticket:created, ticket:updated 
        orders     - order:created, order:cancelled
        payments   - payment:created
        expiration - expiration:complete

    ticket:created
        publisher - tickets service
        listeners:
            - orders service: needs to have info about the ticket

    ticket:updated 
        publisher - tickets service
        listeners:
            - orders service: needs to know updated info and if ticket is reserved successfully

    order:created
        publisher - orders service
        listeners:
            - tickets service: a ticket has been reserved by the order, no futher edits allowed on it
            - payments service: user might submit a payment for the created order
            - expiration service: start a timer (15 min) after which the order expires

    order:cancelled
        publisher - orders service
        listeners:
            - tickets service: the corrsponding ticket should be unreserved, so it can be edited again
            - payments service: incoming payments for this order should be rejected

    expiration:complete
        publisher - expiration service
        listeners:
            - orders service: needs to know 15 min time limit is over, then it can decide whether
                              or not to cancel the order (it might have already been paid)

    payment:created
        publisher - payments service
        listeners:
            - orders service: needs to know that the order has been paid for
            

    Code
        Event interface
        dir - common/src/events
        contains abstact base-publisher and base-listener classes
        there is a file for each event that exports an interface corresponding do the event,
        that describes the subject and data.

        Publisher/Listener class
        dir - {microservice}/src/events
        a class for each publisher/listener corresponding to each event is exported
        it extends the base-publisher/base-listener class with event as the parameter

        to publish/listen an event, create an instance of the class
        ex. publish events from some route 
            >  new OrderCreatedPublisher(natsWrapper.client).publish(...);
            listen to events in src/index.ts file of the microservice
            >  new TicketCreatedListener(natsWrapper.client).listen();

    Versioning records
        all the tickets needs to be versioned to avoid concurrency issues
        the tickets database in both tickets and orders microservice should have same ticket versions
        ticket:created event gives a version = 1 to the ticket
        any further changes (ticket:updated), increments the version by 1

        'mongoose-update-if-current' helps in versioning


Tickets
    Structure
            Route            Method          Body                 Purpose
        /api/tickets          GET            ----           Retrieve all tickets
        /api/tickets/:id      GET            ----           Retrieve ticket with specific ID
        /api/tickets          POST      { title, price }    Create a ticket
        /api/tickets          PUT       { title, price }    Edit a ticket

    Initialization
        Copy: src/app.ts, src/index.ts, src/test, .dockerignore, Dockerfile, 
              package.json, package-lock.json, tsconfig.json from auth dir
              (Remove unecessary code from all the files)
        package.json edit:
            "name": "tickets"
        create infra/k8s/tickets-depl.yaml and infra/k8s/tickets-mongo-depl.yaml
        update the skaffold.yaml and infra/k8s/ingress-srv.yaml files
        >  npm install
        >  docker build -t ps07/tickets .
        >  docker push ps07/tickets
        >  npm install @pstickets/common
        >  npm install mongoose-update-if-current

    Routes 
        index.ts - GET all tickets
        show.ts - GET a ticket with specific id
        new.ts - POST (create) a new ticket
        update.ts - PUT (update) an existing ticket
    
    Testing
        dir - routes/__test__
        one file each for testing all 4 routes

    NATS Client Singleton
        dir - src/nats-wrapper.ts
        use - creates a class NatsWrapper with var: _client(Stan) and func: connect()
                connect(clusterId, clientId, url): Promise
                NATS_CLUSTER_ID=ticketing, NATS_CLIENT_ID={pod_name}, NATS_URL=http://nats-srv:4222
                are stored as environment variables in infra/k8s/tickets-depl.yaml
              an object of the class (common instance) is passed to everywhere in the app: 
              src/index.ts         - connects to NATS SS
              src/routes/new.ts    - publish an event after ticket is saved to the database
              src/routes/update.ts - publish an event after ticket is saved to the database

    Fixing Test suite
        To test the 'publish an event' function ability in routes/new.ts and routes/update.ts,
        we need an instance of NATS client in the testing suite. To do this, we will use Jest to create
        a fake initialized NATS client of NatsWrapper. Jest intercepts the import statements of new.ts and update.ts
        to get natsWrapper and create a fake instance. Steps:
        - file to fake: src/nats-wrapper.ts
        - create src/__mocks__ folder in same dir
        - create file with identical name: src/__mocks__/nats-wrapper.ts
          fake the client.publish() function
        - tell Jest to use the fake file for testing
          in src/test/setup.ts: add jest.mock('../nats-wrapper');
        - use the fake NATS implementation
          in src/routes/__test__/new.test.ts and src/routes/__test__/update.test.ts,
          add: import { natsWrapper } from '../../nats-wrapper';
          Jest will mock this fiile to use the fake one and we can test the functionality by:
            expect(natsWrapper.client.publish).toHaveBeenCalled();


Orders
    Resources
        Order: { userId, status, expiresAt, ticketId }
                userId - user who created this order and is trying to buy a ticket
                status - expired / paid / pending
                expiresAt - time at which order expires (15 min)
                ticketId - ID of the ticket user is trying to buy
        since we have to lookup at ticket to buy an order, we replicate the Tickets db in order service
        to do this, orders service subscibes to ticket:created and ticket:updated (events by tickets service) channels in NATS SS
        Ticket: { title, price, version }

    Structure
            Route            Method         Body                 Purpose
        /api/orders          GET            ----         Retrieve all orders for user maing the request
        /api/orders/:id      GET            ----         Retrieve order with specific ID
        /api/orders          POST        { ticketId }    Create an order to purchase specific ticket
        /api/orders/:id      DELETE         ----         Cancel the order

    Initialization
        Copy: src/app.ts, src/index.ts, src/nats-wrapper.ts, .dockerignore, Dockerfile, 
              package.json, package-lock.json, tsconfig.json from tickets dir
              (Remove unecessary code from all the files)
        package.json edit:
            "name": "orders"
        create infra/k8s/orders-depl.yaml and infra/k8s/orders-mongo-depl.yaml
        update the skaffold.yaml and infra/k8s/ingress-srv.yaml files
        >  npm install
        >  docker build -t ps07/orders .
        >  docker push ps07/orders
        >  npm install mongoose-update-if-current


Expiration
    Function
        - listens to order:created event
        - BullJS library is used (for timers)
          it reminds us to do some task after some duration (15 min)
          a expirationQueue is maintained in the microservice and jobs are sent to a 
          redis server (in memory database) which notifies when a job is completed (15 min)
          the list of jobs in an instance of redis server
        - publishes expiration:complete event

    Initialization
        Copy: src/index.ts, src/nats-wrapper.ts, src/__mocks__ folder, 
              dockerignore, Dockerfile, package.json, tsconfig.json from tickets dir
              (Remove unecessary code from all the files)
        >  npm install
        >  npm install bull @types/bull
        >  docker build -t ps07/expiration .
        >  docker push ps07/expiration
        >  npm update @pstickets/common

    Events
        publishers:
            expiration:complete - order expires after 15 min and is cancelled
        listeners:
            order:created - start a timer (15 min) after which the order expires


Payments
    Resources
        order: { id, status, version, userId, price }
        payment: { orderId, stripeId } 

    Function
        - listens to order:created and order:cancelled event
        - replicates order data from the listened events and stores it in a orders database
          StripeJS library is used for managing payments. 
          following steps are involved in the process:
            - user enterns their credit card details
            - Stripe API returns a token to be used for making the payment
            - create a charge request with { token, orderId }
            - find the order user is trying to pay for
            - make sure that the order belongs to the user and the amount is correct
            - charge the user's credit card using the Stripe API
            - create payment record to store the successful payment
        - publishes payment:complete event

    Initialization
        Copy: src/app.ts, src/index.ts, src/nats-wrapper.ts, src/__mocks__ dir, src/test dir
                dockerignore, Dockerfile, package.json, tsconfig.json from tickets dir
                (Remove unecessary code from all the files)
        >  npm install
        >  docker build -t ps07/payments .
        >  docker push ps07/payments
        >  npm update @pstickets/common
        >  npm install mongoose-update-if-current
        >  npm install stripe
        create an account on https://stripe.com
        get the secret key from 'Get your test API keys' and store it as a secret object
        >  kubectl create secret generic stripe-secret --from-literal STRIPE_KEY={Secret key}
        >  kubectl get secrets
        add the STRIPE_KEY to the payments pod as an environment variable (in infra/k8s/payments-depl.yaml)
        create a stripe instance in src/stripe.ts
        for testing, use "token": "tok_visa"

    Events
        publishers:
            payment:created - someone has paid for the order
        listeners:
            order:created - user might submit a payment for the created order
            order:cancelled - incoming payments for this order should be rejected


CI/CD
    Procedure
        [Local Machine]
        1. make changes to code in the project
        2. commit code to a git branch (other than master)
        3. push branch on Github

        [Github]
        4. Github receives updated branch
        5. manually create a pull request to merge branch into master
        6. Github automatically runs tests for project
        7. after tests pass, merge the PR into master branch
        8. since mater branch has changed, Github builds and deploys

    Initialization
        we will create a single repository for the whole project
        >  git init
        >  git add .
        >  git commit -m "initial commit"
        create a new repository 'ticketing' on github
        >  git remote add origin https://github.com/PS-07/ticketing.git
        >  git push origin master
        go to Action > Set up workflow on github and rename the file as tests.yml
        ticketing/.github/workflows/tests.yml (write the script)
        edit auth/package.json: 
            "scripts": {
                ---
                "test:ci": "jest"
            },
        >  git status       (to see changed files)
        >  git add .
        >  git commit -m "add test script"
        >  git pull origin master
        >  git push origin master